# 2149. Rearrange Array Elements by Sign

You are given a **0-indexed** integer array `nums` of **even** length consisting of an **equal** number of positive and negative integers.

You should return the array of nums such that the the array follows the given conditions:

1. Every **consecutive pair** of integers have **opposite signs**.
2. For all integers with the same sign, the **order** in which they were present in `nums` is **preserved**.
3. The rearranged array begins with a positive integer.

Return _the modified array after rearranging the elements to satisfy the aforementioned conditions_.

&#x20;

**Example 1:**

<pre><code><strong>Input: nums = [3,1,-2,-5,2,-4]
</strong><strong>Output: [3,-2,1,-5,2,-4]
</strong><strong>Explanation:
</strong>The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
</code></pre>

**Example 2:**

<pre><code><strong>Input: nums = [-1,1]
</strong><strong>Output: [1,-1]
</strong><strong>Explanation:
</strong>1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
</code></pre>

&#x20;

**Constraints:**

* `2 <= nums.length <= 2 * 10`<sup>`5`</sup>
* `nums.length` is **even**
* `1 <= |nums[i]| <= 10`<sup>`5`</sup>
* `nums` consists of **equal** number of positive and negative integers.

&#x20;

It is not required to do the modifications in-place.

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[2, 10`<sup>`5`</sup>`]`.
* `-10`<sup>`9`</sup>` ``<= Node.val <= 10`<sup>`9`</sup>
* All `Node.val` are **unique**.
* `p != q`
* `p` and `q` will exist in the BST.



## Solution.

### Recursive:

```cpp
//2 passes

class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        vector<int> pos;
        vector<int> neg;

        int n=nums.size();
        for(int i=0; i<n; i++){
            if(nums[i]>=0){
                pos.push_back(nums[i]);
            }
            else{
                neg.push_back(nums[i]);
            }
        }

        vector<int> ans;
        for(int i=0; i<n/2; i++){
            ans.push_back(pos[i]);
            ans.push_back(neg[i]);
        }

        return ans;
    }
};
```

#### ⏱ Time Complexity

* First loop: `O(n)`
* Second loop: `O(n/2)` ≈ `O(n)`
* Total = **O(n)**

***

#### 💾 Space Complexity

* You’re creating 3 extra vectors:
  * `pos` can hold up to `n/2` elements
  * `neg` can hold up to `n/2` elements
  * `ans` will hold exactly `n` elements

So extra space = `O(n)`
