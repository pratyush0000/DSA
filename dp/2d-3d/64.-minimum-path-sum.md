# 64. Minimum Path Sum

Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

<pre><code><strong>Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
</strong><strong>Output: 7
</strong><strong>Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: grid = [[1,2,3],[4,5,6]]
</strong><strong>Output: 12
</strong></code></pre>

&#x20;

**Constraints:**

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 200`
* `0 <= grid[i][j] <= 200`



## Solution.



### Recursion

```cpp
// this is a recursive solution made by me

class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        return minpathsum(m-1,n-1,grid);
    }

    int minpathsum(int m, int n, vector<vector<int>>& grid){
        //base conditions
        if(m==0 && n==0) return grid[0][0];
        //return max so cost is so huge its not selected
        if(m<0 || n<0) return INT_MAX;
        
        int up = minpathsum(m-1,n,grid);
        int left = minpathsum(m,n-1,grid);

        return min(up,left) + grid[m][n];
    }
};
```

#### ⏱ Time Complexity

* At each cell `(m, n)`, you branch into **two recursive calls** (`up` and `left`).
* Worst case, you branch until you hit `(0,0)` or go out of bounds.
* The recursion tree height is about `(m + n)` (since each step moves one step up or left).
* The number of distinct paths in that tree is exponential — **roughly `O(2^(m+n))`**.

👉 **Time Complexity = O(2^(m+n))** ✅

***

#### 🗂 Space Complexity

* You’re not using any memoization, just recursion.
* The recursion call stack depth is at most `(m + n)` (moving diagonally across the grid).
* That means the **auxiliary space** = `O(m+n)`.

⚠️ It’s **not O(1)**, because the recursion stack grows with grid size.

👉 **Space Complexity = O(m+n)** ✅

***

#### 📌 Final Answer

* **TC:** `O(2^(m+n))`
* **SC:** `O(m+n)` (recursion stack)



### Recursion + Memoization (Top-Down DP)

```cpp
// this is a recursion + memoisation sol (resuts in new grid)

class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> filler(n,-1);
        vector<vector<int>> temp(m,filler);

        return minpathsum(m-1,n-1,temp,grid);
    }

    int minpathsum(int m, int n, vector<vector<int>>& temp, vector<vector<int>>& grid){
        //base conditions
        if(m==0 && n==0) return grid[0][0];
        //return max so cost is so huge its not selected
        if(m<0 || n<0) return INT_MAX;
        //if it is cmoputed already return it
        if(temp[m][n]!=-1) return temp[m][n];
        
        int up = minpathsum(m-1,n,temp,grid);
        int left = minpathsum(m,n-1,temp,grid);

        temp[m][n] = min(up,left) + grid[m][n];
        return temp[m][n];
    }
};
```

#### ⏱ Time Complexity

* Without memoization, each `(m,n)` gets recomputed exponentially many times.
* With memoization, each `(m,n)` is computed **once** and then cached in `temp`.
* Each computation only involves looking at its two neighbors.
* So total work is proportional to the number of cells:

👉 **Time Complexity = O(m \* n)** ✅

***

#### 🗂 Space Complexity

There are **two sources of space** here:

1. **Memo table (`temp`)** → `O(m * n)`
2. **Recursion stack** → depth at most `(m + n)`

So overall:

👉 **Space Complexity = O(m \* n + (m+n)) ≈ O(m \* n)** ✅





### Tabulation with no space optimisation(bottom-up DP)

```cpp
//this is tabulation sol with no space optimisation

class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        vector<vector<int>> dp(m, vector<int>(n, 0));

        //same start
        dp[0][0] = grid[0][0];

        //fix top row
        for(int i=1; i<n; i++){
            dp[0][i] = dp[0][i-1] + grid[0][i];
        }

        //fix leftmost col
        for(int i=1; i<m; i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }


        //rest
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }

        return dp[m-1][n-1];
    }   
};
```

#### ⏱ Time Complexity

* You visit each cell `(i,j)` exactly once.
* Work per cell = O(1) (just a min + add).\
  👉 **O(m · n)**

***

#### 🗂 Space Complexity

* Extra DP table of size `m × n`.
* No recursion stack.\
  👉 **O(m · n)**



### Tabulation with no space optimisation (bottom-up DP)(1 row)

```cpp
//this is tabulation sol with space optimisation
//( 1 row )
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        vector<int> dp(n, 0);

        //same start
        dp[0] = grid[0][0];

        //do it first time
        for(int i=1; i<n; i++){
            dp[i] = dp[i-1] + grid[0][i];
        }


        // process the rest
        for (int i = 1; i < m; i++) {
            // update first col of current row
            dp[0] += grid[i][0];
            for (int j = 1; j < n; j++) {
                dp[j] = grid[i][j] + min(dp[j], dp[j-1]);
            }
        }

        return dp[n-1];
    }   
};
```

#### 🔎 Complexity

* **Time**: `O(m · n)` (every cell still visited once).
* **Space**: `O(n)` (only one row kept).

