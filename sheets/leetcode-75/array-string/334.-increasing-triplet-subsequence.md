# 334. Increasing Triplet Subsequence

Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.

&#x20;

**Example 1:**

<pre><code><strong>Input: nums = [1,2,3,4,5]
</strong><strong>Output: true
</strong><strong>Explanation: Any triplet where i &#x3C; j &#x3C; k is valid.
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: nums = [5,4,3,2,1]
</strong><strong>Output: false
</strong><strong>Explanation: No triplet exists.
</strong></code></pre>

**Example 3:**

<pre><code><strong>Input: nums = [2,1,5,0,4,6]
</strong><strong>Output: true
</strong><strong>Explanation: One of the valid triplet is (3, 4, 5), because nums[3] == 0 &#x3C; nums[4] == 4 &#x3C; nums[5] == 6.
</strong></code></pre>

&#x20;

**Constraints:**

* `1 <= nums.length <= 5 * 10`<sup>`5`</sup>
* `-2`<sup>`31`</sup>` ``<= nums[i] <= 2`<sup>`31`</sup>` ``- 1`

&#x20;

**Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?



## Solution.

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX, second = INT_MAX;

        for (int num : nums) {
            if (num <= first) {
                first = num;   // update smallest
            } else if (num <= second) {
                second = num;  // update second smallest
            } else {
                // found num > second > first
                return true;
            }
        }
        return false;
    }
};
```

#### Complexity

* **TC:** O(n)
* **SC:** O(1)&#x20;

