# 2390. Removing Stars From a String

You are given a string `s`, which contains stars `*`.

In one operation, you can:

* Choose a star in `s`.
* Remove the closest **non-star** character to its **left**, as well as remove the star itself.

Return _the string after **all** stars have been removed_.

**Note:**

* The input will be generated such that the operation is always possible.
* It can be shown that the resulting string will always be unique.

&#x20;

**Example 1:**

<pre><code><strong>Input: s = "leet**cod*e"
</strong><strong>Output: "lecoe"
</strong><strong>Explanation: Performing the removals from left to right:
</strong><strong>- The closest character to the 1st star is 't' in "leet**cod*e". s becomes "lee*cod*e".
</strong><strong>- The closest character to the 2nd star is 'e' in "lee*cod*e". s becomes "lecod*e".
</strong><strong>- The closest character to the 3rd star is 'd' in "lecod*e". s becomes "lecoe".
</strong>There are no more stars, so we return "lecoe".
</code></pre>

**Example 2:**

<pre><code><strong>Input: s = "erase*****"
</strong><strong>Output: ""
</strong><strong>Explanation: The entire string is removed, so we return an empty string.
</strong></code></pre>

&#x20;

**Constraints:**

* `1 <= s.length <= 10`<sup>`5`</sup>
* `s` consists of lowercase English letters and stars `*`.
* The operation above can be performed on `s`.



## Solution.

```cpp
class Solution {
public:
    string removeStars(string s) {
        stack<char> st;
        for(char c : s){
            if(c=='*'){
                if(!st.empty()){
                    st.pop();
                }
            } else {
                st.push(c);
            }
        }

        string result;
        while(!st.empty()){
            result.push_back(st.top());
            st.pop();
        }

        reverse(result.begin(),result.end());
        return result;
    }
};
```

#### Complexity

*   #### **Time Complexity (TC)**

    * You loop once over all characters â†’ **O(n)**
    * Pushing and popping from stack â†’ **O(1)** each, so still **O(n)** total
    * Building result string from stack â†’ **O(n)**
    * Reversing result â†’ **O(n)**

    ðŸ‘‰ Total = **O(n)**
*   **Space Complexity (SC)**

    * Worst case, no `*` at all â†’ all `n` chars stored in stack â†’ **O(n)**
    * `result` string also stores up to `n` characters â†’ **O(n)**
    * Constants (like variables) are **O(1)**

    ðŸ‘‰ Overall auxiliary space = **O(n)**



