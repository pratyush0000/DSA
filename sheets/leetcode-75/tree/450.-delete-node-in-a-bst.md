# 450. Delete Node in a BST

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return _the **root node reference** (possibly updated) of the BST_.

Basically, the deletion can be divided into two stages:

1. Search for a node to remove.
2. If the node is found, delete the node.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

<pre><code><strong>Input: root = [5,3,6,2,4,null,7], key = 3
</strong><strong>Output: [5,4,6,2,null,null,7]
</strong><strong>Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
</strong>One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

</code></pre>

**Example 2:**

<pre><code><strong>Input: root = [5,3,6,2,4,null,7], key = 0
</strong><strong>Output: [5,3,6,2,4,null,7]
</strong><strong>Explanation: The tree does not contain a node with value = 0.
</strong></code></pre>

**Example 3:**

<pre><code><strong>Input: root = [], key = 0
</strong><strong>Output: []
</strong></code></pre>

&#x20;

**Constraints:**

* The number of nodes in the tree is in the range `[0, 10`<sup>`4`</sup>`]`.
* `-10`<sup>`5`</sup>` ``<= Node.val <= 10`<sup>`5`</sup>
* Each node has a **unique** value.
* `root` is a valid binary search tree.
* `-10`<sup>`5`</sup>` ``<= key <= 10`<sup>`5`</sup>

&#x20;

**Follow up:** Could you solve it with time complexity `O(height of tree)`?



## Solution.

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return NULL;
        if(root->val==key) return helper(root);
        TreeNode* dummy=root;
        while(root!=NULL){
            if(root->val>key){
                //node is to the left
                if(root->left!=NULL && root->left->val==key){
                    root->left = helper(root->left);
                    break;
                }else{
                    root=root->left;
                }
            }else{
                //node is to the right
                if(root->right!=NULL && root->right->val==key){
                    root->right = helper(root->right);
                    break;
                }else{
                    root=root->right;
                }
            }
        }
        return dummy;
    }

    TreeNode* helper(TreeNode* root){
        if(root->left==NULL) return root->right;
        if(root->right==NULL) return root->left;
        TreeNode* rightChild = root->right;
        TreeNode* smallest = findLeft(rightChild);
        smallest->left=root->left;
        return rightChild;
    }

    TreeNode* findLeft(TreeNode* root){
        while(root->left!=NULL){
            root=root->left;
        }
        return root;
    }
};
```

#### Complexity

* **Time Complexity:** `O(h)`
* **Space Complexity:** `O(1)`

