# 2336. Smallest Number in Infinite Set

You have a set which contains all positive integers `[1, 2, 3, 4, 5, ...]`.

Implement the `SmallestInfiniteSet` class:

* `SmallestInfiniteSet()` Initializes the **SmallestInfiniteSet** object to contain **all** positive integers.
* `int popSmallest()` **Removes** and returns the smallest integer contained in the infinite set.
* `void addBack(int num)` **Adds** a positive integer `num` back into the infinite set, if it is **not** already in the infinite set.

&#x20;

**Example 1:**

<pre><code><strong>Input
</strong>["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
[[], [2], [], [], [], [1], [], [], []]
<strong>Output
</strong>[null, null, 1, 2, 3, null, 1, 4, 5]

<strong>Explanation
</strong>SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.
</code></pre>

&#x20;

**Constraints:**

* `1 <= num <= 1000`
* At most `1000` calls will be made **in total** to `popSmallest` and `addBack`.



## Solution.

### set

```cpp
class SmallestInfiniteSet {
public:
//my solution will start count with 1, have ntohing in set and will only push in set with addBack, saving time to initialize.
    int count = 0;
    set<int> remaining;

    SmallestInfiniteSet() {

    }
    
    int popSmallest() {
        if(remaining.empty()){
            count++;
            return count;
        } else {
            int smallest = *remaining.begin();
            remaining.erase(remaining.begin());
            return smallest;
        }
    }
    
    void addBack(int num) {
        if (num <= count) {
            remaining.insert(num);
        }
    }
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

#### Complexity

* **`popSmallest()`** → O(1) (if `remaining` empty), otherwise O(log⁡m).
* **`addBack(num)`** → O(log⁡m).
* **Space Complexity** → O(m).

***

### heap

```cpp
class SmallestInfiniteSet {
public:
//we will set a min heap. also need set to keep track of what is in heap, thats why the set method is better.
    priority_queue<int,vector<int>,greater<int>> minheap;
    unordered_set<int> present;

    SmallestInfiniteSet() {
        for(int i=1; i<=1000; i++){
            minheap.push(i);
            present.insert(i);
        }
    }
    
    int popSmallest() {
        int minn = minheap.top();
        minheap.pop();
        present.erase(minn);
        return minn;
    }
    
    void addBack(int num) {
        if(present.find(num)==present.end()){
            minheap.push(num);
            present.insert(num);
        }
    }
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

#### Complexity

#### **popSmallest()**

Steps:

1. `minheap.top()` → **O(1)**.
2. `minheap.pop()` → **O(log n)**.
3. `present.erase(minn)` → **O(1)** average (unordered\_set).

✅ **Total:** **O(log n)**.

#### **addBack(num)**

Steps:

1. `present.find(num)` → **O(1)** average.
2. If not present:
   * `minheap.push(num)` → **O(log n)**.
   * `present.insert(num)` → **O(1)** average.

✅ **Total:** **O(log n)**.

#### **Space Complexity**

* `minheap` stores at most nnn numbers.
* `present` also stores at most nnn numbers.
* Together: **O(2n) = O(n)**.

#### ✅ Final Summary

* **`popSmallest()`** → **O(log n)**
* **`addBack(num)`** → **O(log n)**
* **Space Complexity** → **O(n)**







