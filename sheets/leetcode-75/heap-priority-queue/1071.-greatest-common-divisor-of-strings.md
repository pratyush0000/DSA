# 1071. Greatest Common Divisor of Strings

For two strings `s` and `t`, we say "`t` divides `s`" if and only if `s = t + t + t + ... + t + t` (i.e., `t` is concatenated with itself one or more times).

Given two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`.

&#x20;

**Example 1:**

<pre><code><strong>Input: str1 = "ABCABC", str2 = "ABC"
</strong><strong>Output: "ABC"
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: str1 = "ABABAB", str2 = "ABAB"
</strong><strong>Output: "AB"
</strong></code></pre>

**Example 3:**

<pre><code><strong>Input: str1 = "LEET", str2 = "CODE"
</strong><strong>Output: ""
</strong></code></pre>

&#x20;

**Constraints:**

* `1 <= str1.length, str2.length <= 1000`
* `str1` and `str2` consist of English uppercase letters.



## Solution.

```cpp
class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        return (str1 + str2 == str2 + str1) ? str1.substr(0, gcd(size(str1),size(str2))): "";
    }
};
```

#### **Time Complexity**

1. Checking `(str1 + str2 == str2 + str1)`
   * Concatenation â†’ `O(n + m)`
   * Comparison â†’ `O(n + m)`\
     (where `n = len(str1)`, `m = len(str2)`)
2. `gcd(n, m)`
   * Euclidean algorithm runs in `O(log(min(n, m)))` â†’ very small compared to string ops.
3. `substr(0, gcd(n, m))`
   * Extracts `gcd(n, m)` characters â†’ `O(gcd(n, m))`\
     (â‰¤ `O(min(n, m))`)

ðŸ‘‰ **Total = O(n + m)** (dominated by the concatenation and comparison step).

***

#### **Space Complexity**

* `str1 + str2` and `str2 + str1` â†’ creates two temporary strings of size `O(n + m)`
* The result substring `substr(â€¦)` is at most `O(min(n, m))`

So strictly speaking:

* **Auxiliary space (ignoring output):** `O(1)`
* **Total space (with temporary strings):** `O(n + m)`



