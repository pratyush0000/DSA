# 2360. Longest Cycle in a Graph

You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.

The graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.

Return _the length of the **longest** cycle in the graph_. If no cycle exists, return `-1`.

A cycle is a path that starts and ends at the **same** node.

&#x20;

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png)

<pre><code><strong>Input: edges = [3,3,4,2,3]
</strong><strong>Output: 3
</strong><strong>Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
</strong>The length of this cycle is 3, so 3 is returned.
</code></pre>

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png)

<pre><code><strong>Input: edges = [2,-1,3,1]
</strong><strong>Output: -1
</strong><strong>Explanation: There are no cycles in this graph.
</strong></code></pre>



## Solution.

```cpp
class Solution {
public:
    int longestCycle(vector<int>& edges) {
        int sizee=edges.size();
        vector<int> visited(sizee,0);
        vector<int> depth(sizee, -1);
        int count=-1;

        for(int i=0; i<sizee; i++){
            if(!visited[i]){
                dfs(i,count,depth,0,visited,edges);
            }
        }
        return count;
    }

    void dfs(int node, int& count, vector<int>& depth, int d, vector<int>& visited, vector<int>& edges){
        visited[node]=1;
        depth[node]=d;
        int next = edges[node];

        if (next != -1) {
            if (!visited[next]) {
                dfs(next, count, depth, d+1, visited, edges);
            } else if (visited[next] == 1) {
                count = max(count, d - depth[next] + 1);
            }
        }
        visited[node] = 2;
    }
};
```

#### ðŸ”¹ Problem setup

* Graph is **directed**, represented by `edges[i]` meaning thereâ€™s an edge from `i â†’ edges[i]` (or `-1` if none).
* So, every node has **at most one outgoing edge**.\
  That makes the graph essentially a collection of **disjoint chains + cycles**.

***

#### ðŸ”¹ Time Complexity

* Each node is visited **exactly once** in the DFS (thanks to `visited[node]` states `0 â†’ 1 â†’ 2`).
* Each edge is explored at most once (since out-degree â‰¤ 1, total edges â‰¤ N).
* So complexity is:

O(N+E)

But here Eâ‰¤N, so overall:

O(N)

***

#### ðŸ”¹ Space Complexity

* `visited` â†’ O(N)
* `depth` â†’ O(N)
* Recursion stack (DFS) â†’ worst case O(N)

So total is:

O(N)

***

âœ… Final:

* **Time Complexity:** `O(N)` (or formally `O(N+E)`)
* **Space Complexity:** `O(N)`

