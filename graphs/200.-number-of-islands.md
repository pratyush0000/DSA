# 200. Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

&#x20;

**Example 1:**

<pre><code><strong>Input: grid = [
</strong>  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
<strong>Output: 1
</strong></code></pre>

**Example 2:**

<pre><code><strong>Input: grid = [
</strong>  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
<strong>Output: 3
</strong></code></pre>

&#x20;

**Constraints:**

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 300`
* `grid[i][j]` is `'0'` or `'1'`.



## Solution.

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        //ans
        int count = 0;
        int m = grid.size();
        int n = grid[0].size();

        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j]=='1'){
                    bfs(i,j,m,n,grid);
                    count++;
                }
            }
        }

        return count;
    }

    void bfs(int i, int j, int m, int n, vector<vector<char>>& grid){
        grid[i][j]='2';
        queue<pair<int,int>> qq;
        qq.push({i,j});


        int drow[4] = {-1, 0, 1, 0};
        int dcol[4] = {0, 1, 0, -1};

        while(!qq.empty()){
            int noderow = qq.front().first;
            int nodecol = qq.front().second;
            qq.pop();

            for(int i=0; i<4; i++){
                int currow = noderow + drow[i];
                int currcol = nodecol + dcol[i];

                if(currow>=0 && currow<m && currcol>=0 && currcol<n && grid[currow][currcol]=='1'){
                    qq.push({currow,currcol});
                    grid[currow][currcol]='2';
                }
            }
        }
    }
};
```



#### ðŸ”¹ Time Complexity

* You scan the entire grid once in the outer loop â†’ **O(m Ã— n)**.
* Each time you find a `'1'`, you run **BFS**.
* But notice: **each cell is enqueued/dequeued at most once across the whole algorithm**, because once visited, it is marked `'2'`.
* In BFS, each cell has at most 4 neighbors checked, which is still **O(1)** per cell.

So, the **total BFS work** is bounded by **O(m Ã— n)** over the entire run.

âœ… **Final TC = O(m Ã— n)**

***

#### ðŸ”¹ Space Complexity

* The queue in BFS can, in the worst case, hold **all land cells** (imagine the entire grid is land). Thatâ€™s **O(m Ã— n)** in the worst case.
* Plus, a few O(1) arrays (`drow`, `dcol`).

So,

âœ… **Final SC = O(m Ã— n)** (worst case, when the whole grid is filled with `'1'`).

***

#### ðŸ”¹ Summary

* **TC = O(m Ã— n)**
* **SC = O(m Ã— n)**

